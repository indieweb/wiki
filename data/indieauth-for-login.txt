http://indiewebcamp.com/indieauth-for-login

'''<dfn>[[IndieAuth]] for login</dfn>''' is a user flow and protocol for web applications to implement user  login via an authorization server. The user chooses an authorization server by linking to it from their home page.

== Authorization process ==
[[File:indieauth-login-flow.png]]

# User enters their personal web address in the login form of the web application and clicks "Log in"
# Web application discovers the ''authorization endpoint'' by fetching the user's homepage
# Web application redirects the user's browser to the authorization endpoint
# Authorization endpoint verifies the user, e.g. by logging in
# Authorization endpoint redirects the browser back to the web application, including a token
# Web application verifies the token directly with the authorization endpoint
# User is logged into the web application


__TOC__
== Creating an Authorization Endpoint ==
An authorization endpoint must be able to both generate authorization codes as well as verify authorization codes.

See: [[authorization-endpoint]]

== Web Sign-In Form ==
The site contains a web sign-in form prompting the user to enter their personal web address to sign in.
Upon submitting the form, the site begins the auth process by discovering the user's auth endpoint, e.g.:

[[File:indieauth-web-sign-in.png]]

See http://microformats.org/wiki/web-sign-in for more UI details / possibilities.

=== Discovery ===
The web application checks the user's website for a link with a rel-value of "<tt>authorization_endpoint</tt>":

<pre>&lt;link rel="authorization_endpoint" href="http://indieauth.example.org/"&gt;</pre>

Use this URL as endpoint for processing.

''TODO: MUST HTTP header links be supported?''

=== Authorization Endpoint ===
To start the sign-in flow, the user's browser will be redirected to their authorization endpoint, with additional parameters in the query string.

Directing the user's browser to the auth endpoint is usually done via a HTTP <code>Location</code> header, but can optionally be an <code>&lt;a&gt;</code> tag with an href set to the authorization URL.

==== Request ====

Note: Values are shown with extra linebreaks and without URL encoding for readability.
<pre>
https://auth.example.org/auth
    ?me=https://aaronparecki.com/
    &client_id=https://webapp.example.org/
    &redirect_uri=https://webapp.example.org/auth/callback
    &state=1234567890
    &response_type=id
</pre>

Parameters:
;<tt>me</tt>
: Full URI of the user's homepage
;<tt>client_id</tt>
: Full URI of the application's/website's home page. Used to identify the application. An authorization endpoint may show the application's icon and title to the user during the auth process.
;<tt>redirect_uri</tt>
: Full URI to redirect back to when the login process is finished
;<tt>state</tt>
: Web application-internal state variable; can contain anything
: Optional. Auth endpoints MUST support them, though.
;<tt>response_type</tt>
: <tt>id</tt> (identification only) or <tt>code</tt> (identification + authorization)
: Optional. Defaults to <tt>id</tt>.
;<tt>scope</tt>
: Not used and omitted in identification mode (<tt>response_type=id</tt>)
: For authorization, the scope contains a value (often a verb) that the web application requests permission for, e.g. "post". Multiple values are supported, e.g. <tt>post,delete</tt>

==== Redirect URI verification ====
;why is <tt>redirect_uri</tt> separate from <tt>state</tt>?
: the callback URL shouldn't be dynamic per request so that callback URLs can be registered. "state" is allowed to vary per request
;why should callback urls be registered?
: without registration it's easier to perform a redirect attack. more background here: http://tools.ietf.org/html/rfc6749#section-3.1.2.2
; how does the client website register the callback at the server?
: haven't written this part up yet, but the idea is for the client to publish its registered redirect URIs on its web page with a <link> tag
: since client IDs are always URLs, it's all discoverable that way
: for client_id https://example.com/ a server can find its valid redirect URIs by looking for
:: <tt><link rel="redirect_uri" href="https://example.com/callback"></tt>
: at example.com

==== Verify the user ====
The authorization server should present an interface describing the request being made. It must indicate:

: The <tt>client_id</tt> making the request
:: Optionally the server can include the name and logo if an [[h-card]] is found on the <tt>client_id</tt> URL.
: The <tt>scope</tt> if authorization is requested.

''TODO: Example. See [[h-x-app]].''

=== Redirect to web application ===
The authorization server presents the request information to the user, and if they approve, generates an authorization code and redirects the user to the redirect URI specified.

<pre>
HTTP/1.1 302 Found
Location: https://webapp.example.org/auth/callback
    ?code=xxxxxxxx
    &state=1234567890
    &me=https://aaronparecki.com/
</pre>

Parameters:
;<tt>code</tt>
: Authorization code
;<tt>state</tt>
: State variable sent by the web application
;<tt>me</tt>
: Full URI of the user's homepage

=== Auth code verification ===
The web application finally queries the authorization endpoint to verify the auth code present in the query string. It makes a POST request to the authorization server with the following values:

<pre>
POST https://auth.example.org/auth
Content-type: application/x-www-form-urlencoded

code=xxxxxxxx
&redirect_uri=https://webapp.example.org/auth/callback
&client_id=https://webapp.example.org/
&state=1234567890
</pre>

After the authorization server verifies that <tt>redirect_uri</tt>, <tt>client_id</tt> and <tt>state</tt> match the code given, the response will include the "<tt>me</tt>" value indicating the URL of the user who signed in.

<pre>
HTTP/1.1 200 OK
Content-Type: application/x-www-form-urlencoded

me=https://aaronparecki.com/
</pre>

Parameters:
;<tt>me</tt>
: Full URI of the user's homepage


== Using an Authorization Service ==

You can use an existing authorization service such as [[indieauth.com]] if you don't want to build your own authorization service.


== FAQ ==
==== Why are auth codes verified with a POST instead of a GET ====
If auth codes are sent as a GET request in the query string, they may leak to log files or the HTTP "referer". The decision was made by the OAuth 2.0 working group to use POST requests and the HTTP Authorization header for sending these sensitive tokens and auth codes.
* http://tools.ietf.org/html/rfc6819#section-4.6.7
* http://tools.ietf.org/html/rfc6819#section-5.4.1

==== Can the authorization codes be used more than once ====
No, the authorization code must not be used more than once. If the code is used more than once, the authorization server must deny the request.[http://tools.ietf.org/html/rfc6749#section-4.1.2] A maximum lifetime of 10 minutes is recommended for the authorization codes, although many implementations have a lifetime of 30-60 seconds.

==== Can I add additional parameters for the authorization request ====
No, but you can use the "state" parameter to encode or reference additional application-specific parameters. The state parameter will be passed around and was designed for this purpose as well as to [http://tools.ietf.org/html/rfc6749#section-10.12 prevent CSRF attacks].

==== Does the auth server have to support the state parameter ====
Yes, the state parameter can be used by the client to maintain state between the request and the callback, so the auth server must support it. It is also used to prevent [[CSRF]] attacks.


[[Category:IndieAuth]]
[[Category:building-blocks]]
