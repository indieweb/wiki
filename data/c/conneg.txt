https://indieweb.org/conneg

{{stub}}

'''<dfn>conneg</dfn>''' is short for HTTP Content Negotiation, a method by which a browser or other web client can request content of various types from a web server, and depending on what is requested, and what the server supports, it tries to provide the best it can.

== Caching ==
Content negotiation can pose additional challenges when trying to add caching layers, such as [[nginx]]'s fastcgi or proxy cache. Unless the cache key takes into account the requested content type of the content, the wrong representation may be returned by the cache.

== Tools ==
* [[Go]] library: https://gitlab.com/jamietanna/content-negotiation-go

== See Also ==
* https://en.wikipedia.org/wiki/Content_negotiation
* https://www.mnot.net/blog/2012/04/17/profiles
* https://tools.ietf.org/html/rfc6906
* https://tools.ietf.org/html/rfc7284
* https://github.com/indieweb/micropub-extensions/issues/28
* https://wiki.whatwg.org/wiki/Why_not_conneg
* https://snarfed.org/49619-2
** "Matilda, 1996<br>Also on public-swicg@w3.org.<br>Content negotiation is a feature of HTTP that lets clients ask for, and servers return, different content types based on the request’s Accept header.<br>Sounds great, right? Well, no. Content negotiation is the classic example of an idea that sounds good in theory, but for the vast majority of web developers, turns out to be net harmful in practice. A few reasons:<br>Most web developers are not aware that conneg exists. This is usually fine, since it’s uncommon, but can be an unpleasant surprise when they first hit it and don’t understand it.<br>The Accept header is notoriously complicated to parse, generate, and fully comply with. Imo much of that complexity is unneeded in practice.<br>It often breaks caching when it’s first introduced. Internal and external caches generally ignore Content-Type and Accept (etc) by default, so when conneg is first introduced, clients often get the wrong response type. Developers learn the hard way that they need to add Accept to Vary and to their framework’s cache.<br>URLs leak across contexts. They may start out within a single service or API, but they gradually proliferate into user-visible links, object identifiers in other systems, add-on services, third party tools, etc. These generally don’t know the original conneg requirements, which causes unpleasant surprises.<br>I think most of this boils down to: modality generally considered harmful. When something always behaves the same way, it’s reliable and easy to use. When it behaves differently based on something far away that you may not know exists, it’s unreliable and surprising. Add in a very large ecosystem of independent tools that all need to interoperate, often in fine-grained ways, and you have a recipe for failure." [https://snarfed.org/ @Ryan Barrett] March 24, 2023
